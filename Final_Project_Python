# imports
import random
import time
import sys

# Settings to be used inside game. 7 questions to represent BTS members
settings = {
  "number_of_questions": 7,
  "timer": 10,
  "mode": "classic",
  "choice": "letters" # letters or numbers
}

####################### Start of Classes/Functions #######################
class colors:
  WHITE = "\u001b[37m"
  GREEN = "\033[92m"
  RED = "\033[91m"
  PURPLE = "\033[0;35m"
# Class to easily create a question object
class Quiz:
  # For creating instance of quiz class
  def __init__(self, list):
    try:
      self.question = list[0]

      # Limited to 5 choices only
      self.choice_map = ['a', 'b', 'c', 'd', 'e']
      self.choices = list[1].split(',')

      # Check if there is a choice that always needs to be at the bottom
      self._aoda = "all of the above"
      self._noda = "none of the above"

      try:
        self._aoda_index = self.choices.index(self._aoda)
      except ValueError:
        self._aoda_index = -1
      # Remove AODA or NODA before shuffle
      if self._aoda_index>=0:
        self.choices.pop(self._aoda_index)

      try:
        self._noda_index = self.choices.index(self._noda)
      except ValueError:
        self._noda_index = -1
      if self._noda_index>=0:
        self.choices.pop(self._noda_index)

      # Randomizing the choices
      random.shuffle(self.choices)

      # Put AODA or NODA at the bottom
      if self._aoda_index>=0:
        self.choices.append(self._aoda)
      if self._noda_index>=0:
        self.choices.append(self._noda)


      # Searches for the index of correct answer from the choices
      self.answer = self.choices.index(list[2].strip())

      self.read_time = int(list[3])
      
    except:
      print("There is an issue with the question bank .txt file. Please contact programmer to fix")

  # Method to display choices to console
  def show_choices(self):
    if settings["choice"].lower() == "letters":
      for choice_id, choice in enumerate(self.choices):
        print("   {}. {}".format(self.choice_map[choice_id], choice))
    elif settings["choice"].lower() == "numbers":
      for choice_id, choice in enumerate(self.choices):
        print("   {}. {}".format(choice_id+1, choice))
  
  # Method to get answer from user and return correct or not
  def score_answer(self):
    before = time.time()

    while True:
      ans = input("Your answer: ")
      after = time.time()
      # Time elapsed to answer the question
      anstime = after - before

      if settings["choice"].lower() == "letters":
        try:
          if self.choice_map.index(ans.strip().lower())==self.answer:
            print("{}Correct!{}".format(colors.GREEN, colors.WHITE))
            return self.calc_score(anstime)
          else:
            print("{}Wrong{}".format(colors.RED, colors.WHITE))
            # No score for wrong answers
            return [0, anstime]
        except ValueError:
          # TODO: Fix error message when choice is not available
          print('Choose from a-{} only'.format(self.choice_map[len(self.choices)-1]))
          continue

      elif settings["choice"].lower() == "numbers":
        if int(ans)==(self.answer+1):
          print("{}Correct!{}".format(colors.GREEN, colors.WHITE))
          return self.calc_score(anstime)
        else:
          print("{}Wrong{}".format(colors.RED, colors.WHITE))
          # No score for wrong answers
          return [0, anstime]

  # TODO: Add comments
  def calc_score(self, anstime):
    # TODO: Add comments

    real_time = anstime - self.read_time
    if real_time < 0:
      real_time = 0
    remaining = settings["timer"] - real_time

    max_score_per_question = 100/settings["number_of_questions"]
    # TODO: This can become negative. Either have a setting to control if this will allow negatives
    return [max_score_per_question*(remaining/settings["timer"]), anstime]

 
# Put a timer in console
def start_timer(timer):
  for remaining in range(timer, 0, -1):
    sys.stdout.write("\r")
    sys.stdout.write("Starting in {:2d} seconds.".format(remaining)) 
    sys.stdout.flush()
    time.sleep(1)
  sys.stdout.write("\rStart!                    \n")

####################### End of Classes/Functions #######################

########################### Start of flow ###########################

# TODO: Print welcome message for the quiz
print("\nWelcome to BTS quiz show\n")

# TODO: Print the instruction
print("Choose correct answer. Blah blah Explain scoring here\n")

List_of_Questions = []
user = {
  "username": "Ronnie",
  "score": 0,
  "times": []
}


# Open question bank
# We can specify the directory if we want
BTS_Quiz_bank = "BTS_Quiz_bank.txt"
with open(BTS_Quiz_bank, 'r') as file:
  # Read each line. One line contains one question with its choices and answer
  for line in file:
    object= line.split('? ')
    List_of_Questions.append(Quiz(object))

  # close the file
  file.close()

# Also randomize the questions
random.shuffle(List_of_Questions)

print(colors.PURPLE)                 
print("   ____ _____ ____ ")
print("  | __ )_   _/ ___|   |\  /|")
print("  |  _ \ | | \___ \   | || |")
print("  | |_) || |  ___) |  | || |")
print("  |____/ |_| |____/   |/  \|")
print(colors.WHITE)

#Start Timer
# start_timer(10)

for id in range(0, settings["number_of_questions"]):
  item = List_of_Questions[id]
  # Print question with item number
  print("\n{}) {}".format(str(id+1), item.question))
  item.show_choices()
  
  result = item.score_answer()
  print(result[0])
  user["score"] = user["score"]+result[0]
  user["times"].append(result[1])

print("\n", end="")
for key in user:
  print(user[key])

print(sum(user["times"]))
